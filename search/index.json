[{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) // 定义结构体类型 point type point struct { x, y int } func main() { // 创建结构体实例 p := point{1, 2} // 1. 基本格式输出（默认格式） // 输出: struct1: {1 2} fmt.Printf(\u0026#34;struct1: %v\\n\u0026#34;, p) // 2. 带字段名的结构体输出 // 输出: struct2: {x:1 y:2} fmt.Printf(\u0026#34;struct2: %+v\\n\u0026#34;, p) // 3. Go语法表示的结构体（包含包名和类型） // 输出: struct3: main.point{x:1, y:2} fmt.Printf(\u0026#34;struct3: %#v\\n\u0026#34;, p) // 4. 输出值的类型 // 输出: type: main.point fmt.Printf(\u0026#34;type: %T\\n\u0026#34;, p) // 5. 布尔值输出 // 输出: bool: true fmt.Printf(\u0026#34;bool: %t\\n\u0026#34;, true) // 6. 十进制整数输出 // 输出: int: 123 fmt.Printf(\u0026#34;int: %d\\n\u0026#34;, 123) // 7. 二进制输出 // 输出: bin: 1110 (14的二进制) fmt.Printf(\u0026#34;bin: %b\\n\u0026#34;, 14) // 8. Unicode字符输出 // 输出: char: ! (ASCII 33的字符) fmt.Printf(\u0026#34;char: %c\\n\u0026#34;, 33) // 9. 十六进制输出（小写字母） // 输出: hex: 1c8 (456的十六进制) fmt.Printf(\u0026#34;hex: %x\\n\u0026#34;, 456) // 10. 浮点数默认输出 // 输出: float1: 78.900000 fmt.Printf(\u0026#34;float1: %f\\n\u0026#34;, 78.9) // 11-12. 科学计数法输出（小写e/大写E） // 输出: float2: 1.234000e+08 // 输出: float3: 1.234000E+08 fmt.Printf(\u0026#34;float2: %e\\n\u0026#34;, 123400000.0) fmt.Printf(\u0026#34;float3: %E\\n\u0026#34;, 123400000.0) // 13. 字符串输出（不转义） // 输出: str1: \u0026#34;string\u0026#34; fmt.Printf(\u0026#34;str1: %s\\n\u0026#34;, \u0026#34;\\\u0026#34;string\\\u0026#34;\u0026#34;) // 14. 带引号的字符串输出（安全转义） // 输出: str2: \u0026#34;\\\u0026#34;string\\\u0026#34;\u0026#34; fmt.Printf(\u0026#34;str2: %q\\n\u0026#34;, \u0026#34;\\\u0026#34;string\\\u0026#34;\u0026#34;) // 15. 字符串的十六进制表示（每字节两个字符） // 输出: str3: 6865782074686973 (\u0026#34;hex this\u0026#34;的十六进制) fmt.Printf(\u0026#34;str3: %x\\n\u0026#34;, \u0026#34;hex this\u0026#34;) // 16. 指针地址输出（十六进制表示） // 输出: pointer: 0x...（具体地址值） fmt.Printf(\u0026#34;pointer: %p\\n\u0026#34;, \u0026amp;p) // 17-21. 格式化宽度和对齐控制 ------------------------ // 17. 整数右对齐，宽度6位 // 输出: width1: | 12| 345| fmt.Printf(\u0026#34;width1: |%6d|%6d|\\n\u0026#34;, 12, 345) // 18. 浮点数右对齐，宽度6位，保留2位小数 // 输出: width2: | 1.20| 3.45| fmt.Printf(\u0026#34;width2: |%6.2f|%6.2f|\\n\u0026#34;, 1.2, 3.45) // 19. 浮点数左对齐，宽度6位，保留2位小数 // 输出: width3: |1.20 |3.45 | fmt.Printf(\u0026#34;width3: |%-6.2f|%-6.2f|\\n\u0026#34;, 1.2, 3.45) // 20. 字符串右对齐，宽度6位 // 输出: width4: | foo| b| fmt.Printf(\u0026#34;width4: |%6s|%6s|\\n\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;b\u0026#34;) // 21. 字符串左对齐，宽度6位 // 输出: width5: |foo |b | fmt.Printf(\u0026#34;width5: |%-6s|%-6s|\\n\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;b\u0026#34;) // 22. 格式化字符串到变量（不打印） s := fmt.Sprintf(\u0026#34;sprintf: a %s\u0026#34;, \u0026#34;string\u0026#34;) fmt.Println(s) // 输出: sprintf: a string // 23. 格式化输出到指定IO（这里是标准错误） // 输出到stderr: io: an error fmt.Fprintf(os.Stderr, \u0026#34;io: an %s\\n\u0026#34;, \u0026#34;error\u0026#34;) } ","date":"2025-05-29T21:57:24+08:00","image":"https://highcoldboy.github.io/p/golang-format/fm_hu_507888bab1d21cbc.png","permalink":"https://highcoldboy.github.io/p/golang-format/","title":"格式化输出 format 速查手册"},{"content":"单例模式 适用场景：需要确保一个类只有一个实例，并提供全局访问点（如数据库连接、配置管理）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Database { private static $instance = null; private $connection; private function __construct() { $this-\u0026gt;connection = new PDO(\u0026#39;mysql:host=localhost;dbname=test\u0026#39;, \u0026#39;root\u0026#39;, \u0026#39;\u0026#39;); } public static function getInstance() { if (self::$instance === null) { self::$instance = new self(); } return self::$instance; } public function query($sql) { return $this-\u0026gt;connection-\u0026gt;query($sql); } // 防止克隆 private function __clone(){} } // 使用 $db1 = Database::getInstance(); $db2 = Database::getInstance(); var_dump($db1 === $db2); // 输出 true，确保唯一实例 工厂模式 适用场景：将对象的创建与使用分离，便于扩展（如创建不同类型的支付方式）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 interface Payment { public function pay($amount); } class CreditCardPayment implements Payment { public function pay($amount) { echo \u0026#34;用信用卡支付: {$amount}元\\n\u0026#34;; } } class PayPalPayment implements Payment { public function pay($amount) { echo \u0026#34;用PayPal支付: {$amount}元\\n\u0026#34;; } } class PaymentFactory { private static $paymentMap = [ \u0026#39;credit_card\u0026#39; =\u0026gt; CreditCardPayment::class, \u0026#39;paypal\u0026#39; =\u0026gt; PayPalPayment::class, ]; public static function register(string $type, string $paymentClass): void { // class_implements 返回指定的类实现的所有接口 if (!in_array(Payment::class, class_implements($paymentClass), true)) { throw new InvalidArgumentException(\u0026#34;{$paymentClass} 必须实现 Payment 接口\u0026#34;); } self::$paymentMap[$type] = $paymentClass; } public static function create(string $type): Payment { if (!isset(self::$paymentMap[$type])) { throw new InvalidArgumentException(\u0026#34;未注册的支付类型: {$type}\u0026#34;); } $paymentClass = self::$paymentMap[$type]; return new $paymentClass(); } } // 使用示例 PaymentFactory::register(\u0026#39;paypal\u0026#39;, PayPalPayment::class); $payment = PaymentFactory::create(\u0026#39;paypal\u0026#39;); $payment-\u0026gt;pay(100); // 扩展新支付方式示例 class WeChatPayment implements Payment { public function pay($amount) { echo \u0026#34;用微信支付: {$amount}元\\n\u0026#34;; } } // 注册新类型无需修改工厂类 PaymentFactory::register(\u0026#39;wechat\u0026#39;, WeChatPayment::class); $wxPayment = PaymentFactory::create(\u0026#39;wechat\u0026#39;); $wxPayment-\u0026gt;pay(200); 策略模式 适用场景：定义一系列算法，封装起来并使它们可互换（如不同的折扣算法）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 // 策略接口 interface DiscountStrategy { public function calculate(float $amount): float; } // 具体策略类：无折扣 class NoDiscount implements DiscountStrategy { public function calculate(float $amount): float { return $amount; } } // 具体策略类：固定折扣 class FixedDiscount implements DiscountStrategy { private $discount; public function __construct(float $discount) { $this-\u0026gt;discount = $discount; } public function calculate(float $amount): float { return max($amount - $this-\u0026gt;discount, 0); } } // 具体策略类：百分比折扣 class PercentageDiscount implements DiscountStrategy { private $percentage; public function __construct(float $percentage) { $this-\u0026gt;percentage = $percentage; } public function calculate(float $amount): float { return $amount * (1 - $this-\u0026gt;percentage / 100); } } // 上下文类 class OrderContext { private $strategy; public function __construct(DiscountStrategy $strategy) { $this-\u0026gt;strategy = $strategy; } public function setStrategy(DiscountStrategy $strategy): void { $this-\u0026gt;strategy = $strategy; } public function checkout(float $amount): float { return $this-\u0026gt;strategy-\u0026gt;calculate($amount); } } // 使用示例 $order = new OrderContext(new NoDiscount()); echo \u0026#34;原价100元，无折扣：\u0026#34; . $order-\u0026gt;checkout(100) . \u0026#34;元\\n\u0026#34;; // 100元 $order-\u0026gt;setStrategy(new FixedDiscount(20)); echo \u0026#34;原价100元，立减20：\u0026#34; . $order-\u0026gt;checkout(100) . \u0026#34;元\\n\u0026#34;; // 80元 $order-\u0026gt;setStrategy(new PercentageDiscount(30)); echo \u0026#34;原价100元，7折：\u0026#34; . $order-\u0026gt;checkout(100) . \u0026#34;元\\n\u0026#34;; // 70元 // 动态切换策略 $order-\u0026gt;setStrategy(new FixedDiscount(50)); echo \u0026#34;原价80元，立减50：\u0026#34; . $order-\u0026gt;checkout(80) . \u0026#34;元\\n\u0026#34;; // 30元 工厂模式 Vs 策略模式 关键区别说明：\n目的不同： 策略模式：主要解决算法/行为的灵活替换问题 工厂模式：主要解决对象创建的解耦问题 使用场景： 当需要根据不同条件选择不同算法时用策略模式 当需要隐藏对象创建细节时用工厂模式 生命周期： 策略模式中的策略对象通常在运行时可以动态更换 工厂模式创建的对象通常在使用时即确定类型 组合方式： 策略模式通常表现为组合关系（has-a） 工厂模式通常表现为创建关系（create-a） 在实际开发中，两种模式可以结合使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 策略工厂 class StrategyFactory { public static function create(string $type): DiscountStrategy { return match($type) { \u0026#39;fixed\u0026#39; =\u0026gt; new FixedDiscount(20), \u0026#39;percentage\u0026#39; =\u0026gt; new PercentageDiscount(30), default =\u0026gt; new NoDiscount(), }; } } // 使用组合 $strategy = StrategyFactory::create(\u0026#39;percentage\u0026#39;); $order = new OrderContext($strategy); echo \u0026#34;工厂+策略组合：\u0026#34;.$order-\u0026gt;checkout(100); // 70元 设计选择建议：\n当需要管理多种相似算法时 → 选择策略模式 当需要统一管理对象创建时 → 选择工厂模式 当既要创建不同对象又要管理不同行为时 → 组合使用两种模式 观察者模式 适用场景：当一个对象状态改变时，自动通知依赖它的其他对象（如用户注册后发送邮件和短信）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 // 观察者接口（订阅者） interface OrderObserver { public function update(OrderSubject $subject, string $eventType, $data = null); } // 被观察对象接口（发布者） interface OrderSubject { // 订阅 public function attach(OrderObserver $observer, string $eventType = \u0026#39;*\u0026#39;): void; // 取消订阅 public function detach(OrderObserver $observer, string $eventType = \u0026#39;*\u0026#39;): void; // 通知 public function notify(string $eventType, $data = null): void; } // 具体订单类 class Order implements OrderSubject { private $observers = []; private $orderStatus; private $orderNumber; public function __construct(string $orderNumber) { $this-\u0026gt;orderNumber = $orderNumber; $this-\u0026gt;orderStatus = \u0026#39;created\u0026#39;; } // 实现订阅方法（支持按事件类型订阅） public function attach(OrderObserver $observer, string $eventType = \u0026#39;*\u0026#39;): void { $this-\u0026gt;observers[$eventType][] = $observer; } // 实现取消订阅 public function detach(OrderObserver $observer, string $eventType = \u0026#39;*\u0026#39;): void { if ($eventType === \u0026#39;*\u0026#39;) { foreach ($this-\u0026gt;observers as $type =\u0026gt; $observers) { $this-\u0026gt;removeObserver($type, $observer); } } else { $this-\u0026gt;removeObserver($eventType, $observer); } } // 移除观察者 private function removeObserver(string $eventType, OrderObserver $observer): void { if (isset($this-\u0026gt;observers[$eventType])) { $key = array_search($observer, $this-\u0026gt;observers[$eventType], true); if ($key !== false) { unset($this-\u0026gt;observers[$eventType][$key]); } } } // 状态变更通知 public function notify(string $eventType, $data = null): void { // 通知特定事件类型的观察者 if (isset($this-\u0026gt;observers[$eventType])) { foreach ($this-\u0026gt;observers[$eventType] as $observer) { $observer-\u0026gt;update($this, $eventType, $data); } } // 通知全局观察者（监听所有事件） if (isset($this-\u0026gt;observers[\u0026#39;*\u0026#39;])) { foreach ($this-\u0026gt;observers[\u0026#39;*\u0026#39;] as $observer) { $observer-\u0026gt;update($this, $eventType, $data); } } } // 业务方法：支付订单 public function pay(): void { $this-\u0026gt;orderStatus = \u0026#39;paid\u0026#39;; $this-\u0026gt;notify(\u0026#39;payment_success\u0026#39;, [ \u0026#39;amount\u0026#39; =\u0026gt; 100, \u0026#39;paid_at\u0026#39; =\u0026gt; date(\u0026#39;Y-m-d H:i:s\u0026#39;) ]); } // 业务方法：发货 public function ship(): void { $this-\u0026gt;orderStatus = \u0026#39;shipped\u0026#39;; $this-\u0026gt;notify(\u0026#39;order_shipped\u0026#39;, [ \u0026#39;tracking_number\u0026#39; =\u0026gt; \u0026#39;SF123456789\u0026#39;, \u0026#39;shipped_at\u0026#39; =\u0026gt; date(\u0026#39;Y-m-d H:i:s\u0026#39;) ]); } public function getStatus(): string { return $this-\u0026gt;orderStatus; } public function getOrderNumber(): string { return $this-\u0026gt;orderNumber; } } // 具体观察者：邮件通知服务 class EmailNotifier implements OrderObserver { public function update(OrderSubject $subject, string $eventType, $data = null) { $order = $subject-\u0026gt;getOrderNumber(); switch ($eventType) { case \u0026#39;payment_success\u0026#39;: echo \u0026#34;[邮件通知] 订单 {$order} 支付成功，金额：{$data[\u0026#39;amount\u0026#39;]}元\\n\u0026#34;; break; case \u0026#39;order_shipped\u0026#39;: echo \u0026#34;[邮件通知] 订单 {$order} 已发货，运单号：{$data[\u0026#39;tracking_number\u0026#39;]}\\n\u0026#34;; break; } } } // 具体观察者：短信通知服务 class SMSNotifier implements OrderObserver { public function update(OrderSubject $subject, string $eventType, $data = null) { $order = $subject-\u0026gt;getOrderNumber(); if ($eventType === \u0026#39;payment_success\u0026#39;) { echo \u0026#34;[短信通知] 订单 {$order} 支付成功，感谢您的购买！\\n\u0026#34;; } } } // 具体观察者：数据分析服务（监听所有事件） class AnalyticsService implements OrderObserver { public function update(OrderSubject $subject, string $eventType, $data = null) { $order = $subject-\u0026gt;getOrderNumber(); echo \u0026#34;[数据分析] 记录事件：{$eventType} - 订单 {$order}\\n\u0026#34;; } } // 使用示例 $order = new Order(\u0026#39;ORDER_20230721_001\u0026#39;); // 创建观察者 $emailNotifier = new EmailNotifier(); $smsNotifier = new SMSNotifier(); $analytics = new AnalyticsService(); // 订阅事件 $order-\u0026gt;attach($emailNotifier, \u0026#39;payment_success\u0026#39;); $order-\u0026gt;attach($emailNotifier, \u0026#39;order_shipped\u0026#39;); $order-\u0026gt;attach($smsNotifier, \u0026#39;payment_success\u0026#39;); $order-\u0026gt;attach($analytics); // 监听所有事件 // 执行支付操作 $order-\u0026gt;pay(); /* 输出： [邮件通知] 订单 ORDER_20230721_001 支付成功，金额：100元 [短信通知] 订单 ORDER_20230721_001 支付成功，感谢您的购买！ [数据分析] 记录事件：payment_success - 订单 ORDER_20230721_001 */ // 执行发货操作 $order-\u0026gt;ship(); /* 输出： [邮件通知] 订单 ORDER_20230721_001 已发货，运单号：SF123456789 [数据分析] 记录事件：order_shipped - 订单 ORDER_20230721_001 */ // 取消短信服务的支付成功通知 $order-\u0026gt;detach($smsNotifier, \u0026#39;payment_success\u0026#39;); // 再次支付不会触发短信通知 $order-\u0026gt;pay(); /* 输出： [邮件通知] 订单 ORDER_20230721_001 支付成功，金额：100元 [数据分析] 记录事件：payment_success - 订单 ORDER_20230721_001 */ 装饰器模式 适用场景：动态地为对象添加职责（如给咖啡添加不同的配料）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 // 基础组件接口 interface CoffeeInterface { public function getCost(): float; public function getDescription(): string; } // 具体组件：基础咖啡 class SimpleCoffee implements CoffeeInterface { public function getCost(): float { return 5.0; // 基础价格5元 } public function getDescription(): string { return \u0026#34;普通咖啡\u0026#34;; } } // 装饰器抽象类 abstract class CoffeeDecorator implements CoffeeInterface { protected $coffee; public function __construct(CoffeeInterface $coffee) { $this-\u0026gt;coffee = $coffee; } abstract public function getCost(): float; abstract public function getDescription(): string; } // 具体装饰器：牛奶 class MilkDecorator extends CoffeeDecorator { public function getCost(): float { return $this-\u0026gt;coffee-\u0026gt;getCost() + 1.0; // 加牛奶1元 } public function getDescription(): string { return $this-\u0026gt;coffee-\u0026gt;getDescription() . \u0026#34; + 牛奶\u0026#34;; } } // 具体装饰器：糖 class SugarDecorator extends CoffeeDecorator { public function getCost(): float { return $this-\u0026gt;coffee-\u0026gt;getCost() + 0.5; // 加糖0.5元 } public function getDescription(): string { return $this-\u0026gt;coffee-\u0026gt;getDescription() . \u0026#34; + 糖\u0026#34;; } } // 具体装饰器：奶油 class CreamDecorator extends CoffeeDecorator { public function getCost(): float { return $this-\u0026gt;coffee-\u0026gt;getCost() + 2.0; // 加奶油2元 } public function getDescription(): string { return $this-\u0026gt;coffee-\u0026gt;getDescription() . \u0026#34; + 奶油\u0026#34;; } } // 客户端使用示例 $coffee = new SimpleCoffee(); echo $coffee-\u0026gt;getDescription() . \u0026#34; 价格：\u0026#34; . $coffee-\u0026gt;getCost() . \u0026#34;元\\n\u0026#34;; // 输出：普通咖啡 价格：5元 // 加牛奶 $coffeeWithMilk = new MilkDecorator($coffee); echo $coffeeWithMilk-\u0026gt;getDescription() . \u0026#34; 价格：\u0026#34; . $coffeeWithMilk-\u0026gt;getCost() . \u0026#34;元\\n\u0026#34;; // 输出：普通咖啡 + 牛奶 价格：6元 // 加牛奶和糖 $coffeeWithMilkAndSugar = new SugarDecorator($coffeeWithMilk); echo $coffeeWithMilkAndSugar-\u0026gt;getDescription() . \u0026#34; 价格：\u0026#34; . $coffeeWithMilkAndSugar-\u0026gt;getCost() . \u0026#34;元\\n\u0026#34;; // 输出：普通咖啡 + 牛奶 + 糖 价格：6.5元 // 加奶油、牛奶和糖 $coffeeWithAll = new CreamDecorator($coffeeWithMilkAndSugar); echo $coffeeWithAll-\u0026gt;getDescription() . \u0026#34; 价格：\u0026#34; . $coffeeWithAll-\u0026gt;getCost() . \u0026#34;元\\n\u0026#34;; // 输出：普通咖啡 + 牛奶 + 糖 + 奶油 价格：8.5元 // 动态组合装饰器（奶油+糖） $customCoffee = new CreamDecorator(new SugarDecorator(new SimpleCoffee())); echo $customCoffee-\u0026gt;getDescription() . \u0026#34; 价格：\u0026#34; . $customCoffee-\u0026gt;getCost() . \u0026#34;元\\n\u0026#34;; // 输出：普通咖啡 + 糖 + 奶油 价格：7.5元 ","date":"2025-05-13T20:06:52+08:00","image":"https://highcoldboy.github.io/p/design-pattern/cover_hu_d66c7fac168cdc6d.png","permalink":"https://highcoldboy.github.io/p/design-pattern/","title":"php 常见设计模式"},{"content":"在 php 中， $this 和 $self 都与面向对象编程有关，但是它们的用途和上下文完全不同\n$this 作用： $this 是一个指向当前对象实例的引用（类的实例化对象） 使用场景： 在类的实例方法中访问当前对象的属性和方法 注意点：\n只能在实例方法中使用（静态方法中不可用） 用于区分局部变量和对象属性（例如 $this-\u0026gt;property $property) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class User { private string $name; public function __construct(string $name) { $this-\u0026gt;name = $name; } public function getName(): string { return $this-\u0026gt;name; } } $user = new User(\u0026#39;zs\u0026#39;); $userName = $user-\u0026gt;getName(); self 作用： $self 是一个指向当前类本身的引用（而非实例） 使用场景：\n在类的静态方法或实例方法中访问静态成员（静态属性或静态方法） 用于在类内部调用自身的静态方法或访问静态属性，避免因为继续导致的意外行为（类似 static 但 self 严格指向定义时的类） 注意点：\n可以用于静态和非静态方法中 访问静态成员时需用 :: 操作符（例如 self::$staticProperty) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Counter { private static int $count = 0; public static function getCount(): int { return self::$count; } public function increment(): void { self::$count++; } } $count1 = Counter::getCount(); // 0 $counter1 = new Counter(); $counter1-\u0026gt;increment(); $count2 = Counter::getCount(); // 1 扩展阅读 self vs static self 严格指向定义方法的类，适合不需要继承动态性的场景 static 动态绑定到实际调用的类，适合需要支持多态和继承的场景\nself 例子 self 始终指向定义方法的类，即使在子类中调用也不会改变\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class ParentClass { public static function who(): void { echo \u0026#34;ParentClass\\n\u0026#34;; } public function callWho(): void { self::who(); // 始终调用 ParentClass::who() } } class ChildClass extends ParentClass { public static function who(): void { echo \u0026#34;ChildClass\\n\u0026#34;; } } $obj = new ChildClass(); $obj-\u0026gt;callWho(); // 输出 \u0026#34;ParentClass\u0026#34;（因为 self 指向 ParentClass） static 例子 static 支持后期静态绑定，会指向实际调用的类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class ParentClass { public static function who(): void { echo \u0026#34;ParentClass\\n\u0026#34;; } public function callWho(): void { static::who(); // 动态绑定到实际调用的类 } } class ChildClass extends ParentClass { public static function who(): void { echo \u0026#34;ChildClass\\n\u0026#34;; } } $obj = new ChildClass(); $obj-\u0026gt;callWho(); // 输出 \u0026#34;ChildClass\u0026#34;（因为 static 动态绑定到 ChildClass） 更复杂的继承场景 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Grandparent { public static function who() { echo \u0026#34;Grandparent\\n\u0026#34;; } } class ParentClass extends Grandparent { public static function who(): void { echo \u0026#34;Parent\\n\u0026#34;; } public function callWhoWithSelf(): void { self::who(); // 始终调用 Parent::who() } public function callWhoWithStatic(): void { static::who(); // 动态绑定到实际调用的类 } } class Child extends ParentClass { public static function who(): void { echo \u0026#34;Child\\n\u0026#34;; } } $child = new Child(); $child-\u0026gt;callWhoWithSelf(); // 输出 \u0026#34;Parent\u0026#34;（self 绑定到 Parent） $child-\u0026gt;callWhoWithStatic(); // 输出 \u0026#34;Child\u0026#34;（static 动态绑定到 Child） 实际应用场景 self - 单例模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Singleton { private static ?Singleton $instance = null; private function __construct() { } public static function getInstance(): Singleton { if (self::$instance === null) { self::$instance = new self(); // 固定创建 Singleton 实例 } return self::$instance; } } $s1 = Singleton::getInstance(); $s2 = Singleton::getInstance(); static - 工厂模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 abstract class Logger { /** * Title: 写日志 */ public static function log($message): void { static::writeToLog($message); // 动态调用子类的实现 } /** * Title: 具体写日志的抽象方法 */ protected abstract static function writeToLog($message); } class FileLogger extends Logger { /** * Title: 写文件日志方法 */ protected static function writeToLog($message): void { file_put_contents(\u0026#39;log.txt\u0026#39;, $message, FILE_APPEND); } } FileLogger::log(\u0026#34;Hello\u0026#34;); ","date":"2025-05-12T21:12:58+08:00","image":"https://highcoldboy.github.io/p/php-this-self/cover_hu_6096b98daabe5f45.png","permalink":"https://highcoldboy.github.io/p/php-this-self/","title":"php 类中 this 和 self 的区别"},{"content":"箭头函数 1 2 3 4 5 6 7 8 9 10 11 12 $prefix = \u0026#39;海贼王\u0026#39;; $users = [ [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;路飞\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;lf@hzw.com\u0026#39;], [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;娜美\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;nm@hhzw.com\u0026#39;], [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;汉库克\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;hkk@hzw.com\u0026#39;], ]; $newUsers1 = array_map(function ($user) use ($prefix) { return $prefix . \u0026#39;-\u0026#39; . $user[\u0026#39;name\u0026#39;]; }, $users); $newUsers2 = array_map(fn($user) =\u0026gt; $prefix . \u0026#39;-\u0026#39; . $user[\u0026#39;name\u0026#39;], $users); 注意：PHP7.4+才能支持\n\u0026hellip;解构赋值 1 2 3 4 5 6 7 8 9 10 11 $users = [ [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;路飞\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;lf@hzw.com\u0026#39;], [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;娜美\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;nm@hhzw.com\u0026#39;], [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;汉库克\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;hkk@hzw.com\u0026#39;], ]; ## list($first, $second) = $users; [$first, $second] = $users; $info = [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;路飞\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;lf@hzw.com\u0026#39;, \u0026#39;sex\u0026#39; =\u0026gt; \u0026#39;male\u0026#39;, \u0026#39;age\u0026#39; =\u0026gt; 123]; [\u0026#39;name\u0026#39; =\u0026gt; $name, \u0026#39;email\u0026#39; =\u0026gt; $email] = $info; 使用解构赋值，实现无需中间变量，交换两个变量的值\n1 2 3 4 $a = 11; $b = 22; [$a, $b] = [$b, $a]; echo $a, \u0026#39;--\u0026#39;,$b; match 表达式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 switch ($code) { case 200: $msg2 = \u0026#39;成功\u0026#39;; break; case 404: $msg2 = \u0026#39;没找到\u0026#39;; break; case 401: $msg2 = \u0026#39;没权限\u0026#39;; break; default: $msg2 = \u0026#39;未知\u0026#39;; } ## 比较时也会比较数据类型 $msg3 = match ($code) { 200 =\u0026gt; \u0026#39;成功\u0026#39;, 404 =\u0026gt; \u0026#39;没找到\u0026#39;, 401 =\u0026gt; \u0026#39;没权限\u0026#39;, default =\u0026gt; \u0026#39;未知\u0026#39;, }; $statusCode = [200 =\u0026gt; \u0026#39;成功\u0026#39;, \u0026#39;404\u0026#39; =\u0026gt; \u0026#39;没找到\u0026#39;, 401 =\u0026gt; \u0026#39;没权限\u0026#39;]; $msg1 = $statusCode[$code] ?? \u0026#39;未知\u0026#39;; 注意：PHP8.0+才能支持\nnullsafe运算符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class User { private string $name; private string $gender; public function __construct(string $name, string $gender) { $this-\u0026gt;name = $name; $this-\u0026gt;gender = $gender; } public function getInfo(): string { return $this-\u0026gt;name . \u0026#39; \u0026#39; . $this-\u0026gt;gender; } } class Work { private User $user; public function __construct(User $user) { $this-\u0026gt;user = $user; } public function getUser(): User { return $this-\u0026gt;user; } } $user = new User(\u0026#39;zs\u0026#39;, \u0026#39;male\u0026#39;); $work = (new Work($user)); $userInfo = $work?-\u0026gt;getUser()?-\u0026gt;getInfo(); 注意：PHP8.0+才能支持\n数组解构搭配 list 1 2 3 4 5 6 7 8 9 $users = [ [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;路飞\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;lf@hzw.com\u0026#39;], [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;娜美\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;nm@hhzw.com\u0026#39;], [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;汉库克\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;hkk@hzw.com\u0026#39;], ]; foreach ($users as [\u0026#39;name\u0026#39; =\u0026gt; $name, \u0026#39;email\u0026#39; =\u0026gt; $email]) { echo $name, \u0026#39;-\u0026#39;, $email, \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; } 注意：PHP7.1+才能支持\nusort 搭配太空船操作符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $users = [ [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;路飞\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;lf@hzw.com\u0026#39;, \u0026#39;age\u0026#39; =\u0026gt; 111], [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;娜美\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;nm@hhzw.com\u0026#39;, \u0026#39;age\u0026#39; =\u0026gt; 44], [\u0026#39;name\u0026#39; =\u0026gt; \u0026#39;汉库克\u0026#39;, \u0026#39;email\u0026#39; =\u0026gt; \u0026#39;hkk@hzw.com\u0026#39;, \u0026#39;age\u0026#39; =\u0026gt; 78], ]; ## 根据年龄从小到大 // usort($users, function ($a, $b) { // if ($a[\u0026#39;age\u0026#39;] == $b[\u0026#39;age\u0026#39;]) return 0; // return ($a[\u0026#39;age\u0026#39;] \u0026gt; $b[\u0026#39;age\u0026#39;]) ? 1 : -1; // }); usort($users, function ($a, $b) { return $a[\u0026#39;age\u0026#39;] \u0026lt;=\u0026gt; $b[\u0026#39;age\u0026#39;]; }); 合并数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $arr1 = [\u0026#39;a\u0026#39; =\u0026gt; \u0026#39;apple\u0026#39;, 3 =\u0026gt; \u0026#39;banana\u0026#39;]; $arr2 = [\u0026#39;a\u0026#39; =\u0026gt; \u0026#39;apricot\u0026#39;, 5 =\u0026gt; \u0026#39;berry\u0026#39;, 3 =\u0026gt; \u0026#39;cherry\u0026#39;]; $result = array_merge($arr1,$arr2); // [0 =\u0026gt; \u0026#39;banana\u0026#39;,1 =\u0026gt; \u0026#39;berry\u0026#39;,2 =\u0026gt; \u0026#39;cherry\u0026#39;,\u0026#39;a\u0026#39;=\u0026gt;\u0026#39;apricot\u0026#39;] $result2 = $arr1 + $arr2; // [3 =\u0026gt; \u0026#39;banana\u0026#39;,5 =\u0026gt; \u0026#39;berry\u0026#39;,\u0026#39;a\u0026#39;=\u0026gt;\u0026#39;apple\u0026#39;] $result3 = array_merge($arr2); // [0 =\u0026gt; \u0026#39;berry\u0026#39;,1 =\u0026gt; \u0026#39;cherry\u0026#39;,\u0026#39;a\u0026#39;=\u0026gt;\u0026#39;apricot\u0026#39;] // 直接修改原数组 $arr1 += $arr2 需要覆盖同名键且重新索引数字键 → array_merge 需要保留左侧数据，仅补充新键 → + 运算符\n","date":"2025-05-11T18:11:07+08:00","image":"https://highcoldboy.github.io/p/php-syntactic-sugar/cover_hu_3b66170062bf06d3.png","permalink":"https://highcoldboy.github.io/p/php-syntactic-sugar/","title":"php 奇淫巧技"}]